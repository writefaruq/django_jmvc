c({"name": "jQuery.Model", "type": "class", "comment": "<p>Models super-charge an application's\ndata layer, making it easy to:</p>\n\n<ul>\n<li>Get and modify data from the server</li>\n<li>Listen to changes in data</li>\n<li>Setting and retrieving models on elements</li>\n<li>Deal with lists of data</li>\n<li>Do other good stuff</li>\n</ul>\n\n<p>Model inherits from [jQuery.Class $.Class] and make use\nof REST services and [http://api.jquery.com/category/deferred-object/ deferreds]\nso these concepts are worth exploring.  Also, \nthe [mvc.model Get Started with jQueryMX] has a good walkthrough of $.Model.</p>\n\n<h2>Get and modify data from the server</h2>\n\n<p>$.Model makes connecting to a JSON REST service \nreally easy.  The following models <code>todos</code> by\ndescribing the services that can create, retrieve,\nupdate, and delete todos. </p>\n\n<pre><code>$.Model('Todo',{\n  findAll: 'GET /todos.json',\n  findOne: 'GET /todos/{id}.json',\n  create:  'POST /todos.json',\n  update:  'PUT /todos/{id}.json',\n  destroy: 'DELETE /todos/{id}.json' \n},{});\n</code></pre>\n\n<p>This lets you create, retrieve, update, and delete\ntodos programatically:</p>\n\n<p><strong>Create</strong></p>\n\n<p>Create a todo instance and \ncall <code>[$.Model::save save](success, error)</code>\nto create the todo on the server.</p>\n\n<pre><code>// create a todo instance\nvar todo = new Todo({name: \"do the dishes\"})\n\n// save it on the server\ntodo.save();\n</code></pre>\n\n<p><strong>Retrieve</strong></p>\n\n<p>Retrieve a list of todos from the server with\n<code>[$.Model.findAll findAll](params, callback(items))</code>: </p>\n\n<pre><code>Todo.findAll({}, function( todos ){\n\n  // print out the todo names\n  $.each(todos, function(i, todo){\n    console.log( todo.name );\n  });\n});\n</code></pre>\n\n<p>Retrieve a single todo from the server with\n<code>[$.Model.findOne findOne](params, callback(item))</code>:</p>\n\n<pre><code>Todo.findOne({id: 5}, function( todo ){\n\n  // print out the todo name\n  console.log( todo.name );\n});\n</code></pre>\n\n<p><strong>Update</strong></p>\n\n<p>Once an item has been created on the server,\nyou can change its properties and call\n<code>save</code> to update it on the server.</p>\n\n<pre><code>// update the todos' name\ntodo.attr('name','Take out the trash')\n\n// update it on the server\ntodo.save()\n</code></pre>\n\n<p><strong>Destroy</strong></p>\n\n<p>Call <code>[$.Model.prototype.destroy destroy](success, error)</code>\nto delete an item on the server.</p>\n\n<pre><code>todo.destroy()\n</code></pre>\n\n<h2>Listen to changes in data</h2>\n\n<p>Listening to changes in data is a critical part of \nthe [http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller Model-View-Controller]\narchitecture.  $.Model lets you listen to when an item is created, updated, destroyed\nor its properties are changed. Use \n<code>Model.[$.Model.bind bind](eventType, handler(event, model))</code>\nto listen to all events of type on a model and\n<code>model.[$.Model.prototype.bind bind](eventType, handler(event))</code>\nto listen to events on a specific instance.</p>\n\n<p><strong>Create</strong></p>\n\n<pre><code>// listen for when any todo is created\nTodo.bind('created', function( ev, todo ) {...})\n\n// listen for when a specific todo is created\nvar todo = new Todo({name: 'do dishes'})\ntodo.bind('created', function( ev ) {...})\n</code></pre>\n\n<p><strong>Update</strong></p>\n\n<pre><code>// listen for when any todo is updated\nTodo.bind('updated', function( ev, todo ) {...})\n\n// listen for when a specific todo is created\nTodo.findOne({id: 6}, function( todo ) {\n  todo.bind('updated', function( ev ) {...})\n})\n</code></pre>\n\n<p><strong>Destroy</strong></p>\n\n<pre><code>// listen for when any todo is destroyed\nTodo.bind('destroyed', function( ev, todo ) {...})\n\n// listen for when a specific todo is destroyed\ntodo.bind('destroyed', function( ev ) {...})\n</code></pre>\n\n<p><strong>Property Changes</strong></p>\n\n<pre><code>// listen for when the name property changes\ntodo.bind('name', function(ev){  })\n</code></pre>\n\n<p><strong>Listening with Controller</strong></p>\n\n<p>You should be using controller to listen to model changes like:</p>\n\n<pre><code>$.Controller('Todos',{\n  \"{Todo} updated\" : function(Todo, ev, todo) {...}\n})\n</code></pre>\n\n<h2>Setting and retrieving data on elements</h2>\n\n<p>Almost always, we use HTMLElements to represent\ndata to the user.  When that data changes, we update those\nelements to reflect the new data.</p>\n\n<p>$.Model has helper methods that make this easy.  They\nlet you \"add\" a model to an element and also find\nall elements that have had a model \"added\" to them.</p>\n\n<p>Consider a todo list widget\nthat lists each todo in the page and when a todo is\ndeleted, removes it.  </p>\n\n<p><code>[jQuery.fn.model $.fn.model](item)</code> lets you set or read a model \ninstance from an element:</p>\n\n<pre><code>Todo.findAll({}, function( todos ) {\n\n  $.each(todos, function(todo) {\n    $('&lt;li&gt;').model(todo)\n             .text(todo.name)\n             .appendTo('#todos')\n  });\n});\n</code></pre>\n\n<p>When a todo is deleted, get its element with\n<code>item.[$.Model.prototype.elements elements](context)</code>\nand remove it from the page.</p>\n\n<pre><code>Todo.bind('destroyed', function( ev, todo ) { \n  todo.elements( $('#todos') ).remove()\n})\n</code></pre>\n\n<p><strong>Using EJS and $.Controller</strong></p>\n\n<p>[jQuery.View $.View] and [jQuery.EJS EJS] makes adding model data \nto elements easy.  We can implement the todos widget like the following:</p>\n\n<pre><code>$.Controller('Todos',{\n  init: function(){\n    this.element.html('//todos/views/todos.ejs', Todo.findAll({}) ); \n  },\n  \"{Todo} destroyed\": function(Todo, ev, todo) {\n    todo.elements( this.element ).remove()\n  }\n})\n</code></pre>\n\n<p>In todos.ejs</p>\n\n<pre><code class='html'>&lt;% for(var i =0; i &lt; todos.length; i++){ %>\n  &lt;li &lt;%= todos[i] %>>&lt;%= todos[i].name %>&lt;/li>\n&lt;% } %></code></pre>\n\n<p>Notice how you can add a model to an element with <code>&lt;%= model %&gt;</code></p>\n\n<h2>Lists</h2>\n\n<p>[$.Model.List $.Model.List] lets you handle multiple model instances\nwith ease.  A List acts just like an <code>Array</code>, but you can add special properties \nto it and listen to events on it.  </p>\n\n<p><code>$.Model.List</code> has become its own plugin, read about it\n[$.Model.List here].</p>\n\n<h2>Other Good Stuff</h2>\n\n<p>Model can make a lot of other common tasks much easier.</p>\n\n<h3>Type Conversion</h3>\n\n<p>Data from the server often needs massaging to make it more useful \nfor JavaScript.  A typical example is date data which is \ncommonly passed as\na number representing the Julian date like:</p>\n\n<pre><code>{ name: 'take out trash', \n  id: 1,\n  dueDate: 1303173531164 }\n</code></pre>\n\n<p>But instead, you want a JavaScript date object:</p>\n\n<pre><code>date.attr('dueDate') //-&gt; new Date(1303173531164)\n</code></pre>\n\n<p>By defining property-type pairs in [$.Model.attributes attributes],\nyou can have model auto-convert values from the server into more useful types:</p>\n\n<pre><code>$.Model('Todo',{\n  attributes : {\n    dueDate: 'date'\n  }\n},{})\n</code></pre>\n\n<h3>Associations</h3>\n\n<p>The [$.Model.attributes attributes] property also \nsupports associations. For example, todo data might come back with\nUser data as an owner property like:</p>\n\n<pre><code>{ name: 'take out trash', \n  id: 1, \n  owner: { name: 'Justin', id: 3} }\n</code></pre>\n\n<p>To convert owner into a User model, set the owner type as the User's\n[$.Model.model model]<code>( data )</code> method:</p>\n\n<pre><code>$.Model('Todo',{\n  attributes : {\n    owner: 'User.model'\n  }\n},{})\n</code></pre>\n\n<h3>Helper Functions</h3>\n\n<p>Often, you need to perform repeated calculations \nwith a model's data.  You can create methods in the model's \nprototype and they will be available on \nall model instances.  </p>\n\n<p>The following creates a <code>timeRemaining</code> method that\nreturns the number of seconds left to complete the todo:</p>\n\n<pre><code>$.Model('Todo',{\n},{\n   timeRemaining : function(){\n     return new Date() - new Date(this.dueDate)\n   }\n})\n\n// create a todo\nvar todo = new Todo({dueDate: new Date()});\n\n// show off timeRemaining\ntodo.timeRemaining() //-&gt; Number\n</code></pre>\n\n<h3>Deferreds</h3>\n\n<p>Model methods that make requests to the server such as:\n[$.Model.findAll findAll], [$.Model.findOne findOne], \n[$.Model.prototype.save save], and [$.Model.prototype.destroy destroy] return a\n[jquery.model.deferreds deferred] that resolves to the item(s)\nbeing retrieved or modified.  </p>\n\n<p>Deferreds can make a lot of asynchronous code much easier.  For example, the following\nwaits for all users and tasks before continuing :</p>\n\n<pre><code>$.when(Task.findAll(), User.findAll())\n  .then(function( tasksRes, usersRes ){ ... })\n</code></pre>\n\n<h3>Validations</h3>\n\n<p>[jquery.model.validations Validate] your model's attributes.</p>\n\n<pre><code>$.Model(\"Contact\",{\ninit : function(){\n    this.validate(\"birthday\",function(){\n        if(this.birthday &gt; new Date){\n            return \"your birthday needs to be in the past\"\n        }\n    })\n}\n,{});\n</code></pre>", "parents": ["jquerymx"], "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/model/model.js", "test": "jquery/model/qunit.html", "plugin": "jquery/model", "description": "Models and apps data layer.", "src": "jquery/model/model.js", "line": 176, "children": ["jQuery.Model.static", "jQuery.Model.prototype"]})