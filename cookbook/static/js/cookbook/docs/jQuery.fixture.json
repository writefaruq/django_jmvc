c({"name": "jQuery.fixture", "params": {"settings": {"description": "<p>Configures the AJAX requests the fixture should \nintercept.  If an <strong>object</strong> is passed, the object's properties and values\nare matched against the settings passed to $.ajax.  </p>\n\n<p>If a <strong>string</strong> is passed, it can be used to match the url and type. Urls\ncan be templated, using <code>{NAME}</code> as wildcards.  </p>", "type": "Object|String", "optional": false, "order": 0, "name": "settings"}, "fixture": {"description": "<p>The response to use for the AJAX \nrequest. If a <strong>string</strong> url is passed, the ajax request is redirected\nto the url. If a <strong>function</strong> is provided, it looks like:</p>\n\n<pre><code>fixture( originalSettings, settings, headers    )\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li>originalSettings - the orignal settings passed to $.ajax</li>\n<li>settings - the settings after all filters have run</li>\n<li>headers - request headers</li>\n</ul>\n\n<p>If <strong>null</strong> is passed, and there is a fixture at settings, that fixture will be removed,\nallowing the AJAX request to behave normally.</p>", "type": "Function|String", "optional": false, "order": 1, "name": "fixture"}}, "ret": {"type": "undefined", "description": ""}, "type": "function", "comment": "<p><code>$.fixture</code> intercepts a AJAX request and simulates\nthe response with a file or function. They are a great technique \nwhen you want to develop JavaScript \nindependently of the backend. </p>\n\n<h2>Types of Fixtures</h2>\n\n<p>There are two common ways of using fixtures.  The first is to \nmap Ajax requests to another file.  The following \nintercepts requests to <code>/tasks.json</code> and directs them \nto <code>fixtures/tasks.json</code>:</p>\n\n<pre><code>$.fixture(\"/tasks.json\",\"fixtures/tasks.json\");\n</code></pre>\n\n<p>The other common option is to generate the Ajax response with\na function.  The following intercepts updating tasks at\n<code>/tasks/ID.json</code> and responds with updated data:</p>\n\n<pre><code>$.fixture(\"PUT /tasks/{id}.json\", function(original, settings, headers){\n   return { updatedAt : new Date().getTime() }\n})\n</code></pre>\n\n<p>We categorize fixtures into the following types:</p>\n\n<ul>\n<li><strong>Static</strong> - the response is in a file.</li>\n<li><strong>Dynamic</strong> - the response is generated by a function.</li>\n</ul>\n\n<p>There are different ways to lookup static and dynamic fixtures.</p>\n\n<h2>Static Fixtures</h2>\n\n<p>Static fixtures use an alternate url as the response of the Ajax request.</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\n$.fixture(\"tasks/1\", \"fixtures/task1.json\");\n\n$.fixture(\"tasks/1\", \"//fixtures/task1.json\");\n</code></pre>\n\n<h2>Dynamic Fixtures</h2>\n\n<p>Dynamic Fixtures are functions that get the details of \nthe Ajax request and return the result of the mocked service\nrequest from your server.  </p>\n\n<p>For example, the following returns a successful response \nwith JSON data from the server:</p>\n\n<pre><code>$.fixture(\"/foobar.json\", function(orig, settings, headers){\n  return [200, \"success\", {json: {foo: \"bar\" } }, {} ]\n})\n</code></pre>\n\n<p>The fixture function has the following signature:</p>\n\n<pre><code>function( originalOptions, options, headers ) {\n  return [ status, statusText, responses, responseHeaders ]\n}\n</code></pre>\n\n<p>where the fixture function is called with:</p>\n\n<ul>\n<li>originalOptions - are the options provided to the ajax method, unmodified,\nand thus, without defaults from ajaxSettings</li>\n<li>options - are the request options</li>\n<li>headers - a map of key/value request headers</li>\n</ul>\n\n<p>and the fixture function returns an array as arguments for  ajaxTransport's <code>completeCallback</code> with:</p>\n\n<ul>\n<li>status - is the HTTP status code of the response.</li>\n<li>statusText - the status text of the response</li>\n<li>responses - a map of dataType/value that contains the responses for each data format supported</li>\n<li>headers - response headers</li>\n</ul>\n\n<p>However, $.fixture handles the \ncommon case where you want a successful response with JSON data.  The \nprevious can be written like:</p>\n\n<pre><code>$.fixture(\"/foobar.json\", function(orig, settings, headers){\n  return {foo: \"bar\" };\n})\n</code></pre>\n\n<p>If you want to return an array of data, wrap your array in another array:</p>\n\n<pre><code>$.fixture(\"/tasks.json\", function(orig, settings, headers){\n  return [ [ \"first\",\"second\",\"third\"] ];\n})\n</code></pre>\n\n<p>$.fixture works closesly with jQuery's \najaxTransport system.  Understanding it is the key to creating advanced\nfixtures.</p>\n\n<h3>Templated Urls</h3>\n\n<p>Often, you want a dynamic fixture to handle urls \nfor multiple resources (for example a REST url scheme). $.fixture's\ntemplated urls allow you to match urls with a wildcard.  </p>\n\n<p>The following example simulates services that get and update 100 todos.  </p>\n\n<pre><code>// create todos\nvar todos = {};\nfor(var i = 0; i &lt; 100; i++) {\n  todos[i] = {\n    id: i,\n    name: \"Todo \"+i\n  }\n}\n$.fixture(\"GET /todos/{id}\", function(orig){\n  // return the JSON data\n  // notice that id is pulled from the url and added to data\n  return todos[orig.data.id]\n})\n$.fixture(\"PUT /todos/{id}\", function(orig){\n  // update the todo's data\n  $.extend( todos[orig.data.id], orig.data );\n\n  // return data\n  return {};\n})\n</code></pre>\n\n<p>Notice that data found in templated urls (ex: <code>{id}</code>) is added to the original\ndata object.</p>\n\n<h2>Simulating Errors</h2>\n\n<p>The following simulates an unauthorized request \nto <code>/foo</code>.</p>\n\n<pre><code>$.fixture(\"/foo\", function(){\n    return [401,\"{type: 'unauthorized'}\"]\n   });\n</code></pre>\n\n<p>This could be received by the following Ajax request:</p>\n\n<pre><code>$.ajax({\n  url: '/foo',\n  error : function(jqXhr, status, statusText){\n    // status === 'error'\n    // statusText === \"{type: 'unauthorized'}\"\n  }\n})\n</code></pre>\n\n<h2>Turning off Fixtures</h2>\n\n<p>You can remove a fixture by passing <code>null</code> for the fixture option:</p>\n\n<pre><code>// add a fixture\n$.fixture(\"GET todos.json\",\"//fixtures/todos.json\");\n\n// remove the fixture\n$.fixture(\"GET todos.json\", null)\n</code></pre>\n\n<p>You can also set [jQuery.fixture.on $.fixture.on] to false:</p>\n\n<pre><code>$.fixture.on = false;\n</code></pre>\n\n<h2>Make</h2>\n\n<p>[jQuery.fixture.make $.fixture.make] makes a CRUD service layer that handles sorting, grouping,\nfiltering and more.</p>\n\n<h2>Testing Performance</h2>\n\n<p>Dynamic fixtures are awesome for performance testing.  Want to see what \n10000 files does to your app's performance?  Make a fixture that returns 10000 items.</p>\n\n<p>What to see what the app feels like when a request takes 5 seconds to return?  Set\n[jQuery.fixture.delay] to 5000.</p>\n\n<div class='demo_wrapper' data-demo-src='jquery/dom/fixture/fixture.html'></div>", "plugin": "jquery/dom/fixture", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/dom/fixture/fixture.js", "test": "jquery/dom/fixture/qunit.html", "parents": ["dom"], "src": "jquery/dom/fixture/fixture.js", "line": 181, "children": ["jQuery.fixture.make", "jQuery.fixture.rand", "jquery.fixture.0organizing"]})